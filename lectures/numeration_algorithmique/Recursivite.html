<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Recherche" href="search.html" /><link rel="prev" title="Exemples de classe" href="ExemplesObjet.html" />

    <meta name="generator" content="sphinx-3.4.3, furo 2021.04.11.beta34"/>
        <title>La récursivité - Documentation INFO501 2.0.0</title>
      <link rel="stylesheet" href="_static/styles/furo.css?digest=59ab60ac09ea94ccfe6deddff6d715cce948a6fc">
    <link rel="stylesheet" href="_static/pygments.css">
    <link media="(prefers-color-scheme: dark)" rel="stylesheet" href="_static/pygments_dark.css">
    


<style>
  :root {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media (prefers-color-scheme: dark) {
    :root {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
  }

  /* For allowing end-user-specific overrides */
  .override-light {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  .override-dark {
    --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
  }
</style><link rel="stylesheet" href="_static/styles/furo-extensions.css?digest=d391b54134226e4196576da3bdb6dddb7e05ba2b"></head>
  <body dir="">
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke-width="1.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z"/>
      <line x1="4" y1="6" x2="20" y2="6" />
      <line x1="10" y1="12" x2="20" y2="12" />
      <line x1="6" y1="18" x2="20" y2="18" />
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
      class="feather feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
      class="feather feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="Index.html"><div class="brand">Documentation INFO501 2.0.0</div></a>
    </div>
    <div class="header-right">
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="Index.html">
  
  
  <span class="sidebar-brand-text">Documentation INFO501 2.0.0</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html">
  <input class="sidebar-search" placeholder=Recherche name="q">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Numeration.html">Notion de représentation des données</a></li>
<li class="toctree-l1"><a class="reference internal" href="ProgrammerEnPython.html">Programmer en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="ExemplesFonction.html">Exemples de fonction</a></li>
<li class="toctree-l1"><a class="reference internal" href="NotionObjet.html">Notion d’objet</a></li>
<li class="toctree-l1"><a class="reference internal" href="DefinirClasses.html">Définir des classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="ExemplesObjet.html">Exemples de classe</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">La récursivité</a></li>
</ul>

</div>
</div>
      </div>
      
    </div>
  </aside>
  <main class="main">
    <div class="content">
      <article role="main">
        <label class="toc-overlay-icon toc-content-icon" for="__toc">
          <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
        </label>
        <div class="section" id="la-recursivite">
<h1>La récursivité<a class="headerlink" href="#la-recursivite" title="Lien permanent vers ce titre">¶</a></h1>
<div class="section" id="definitions">
<h2>Définitions<a class="headerlink" href="#definitions" title="Lien permanent vers ce titre">¶</a></h2>
<ul>
<li><p>Définition de Wikipédia de la <a class="reference external" href="https://fr.wikipedia.org/wiki/R%C3%A9cursivit%C3%A9">récursivité</a> en informatique et en logique</p>
<blockquote>
<div><p><em>En informatique et en logique, une fonction ou plus généralement un algorithme
qui contient un appel à elle-même est dite récursive. Deux fonctions peuvent
s’appeler l’une l’autre, on parle alors de récursivité croisée</em>.</p>
</div></blockquote>
</li>
<li><p>Définition d’un dictionnaire imaginaire</p>
<blockquote>
<div><p><em>Récursivité</em>: Si vous n’avez pas compris voir <em>Récursivité</em>.</p>
<p>Cette définition met en évidence la nécessité d’une condition d’arrêt
pour une exécution correcte sur une machine informatique.</p>
</div></blockquote>
</li>
</ul>
<p>Dans ce chapitre, nous illustrerons ce principe à partir de quelques exemples qui
permettront de montrer la simplicité de codage mais aussi les limites de cette approche.</p>
</div>
<div class="section" id="calcul-de-n">
<h2>Calcul de <em>n</em>!<a class="headerlink" href="#calcul-de-n" title="Lien permanent vers ce titre">¶</a></h2>
<p>On a vu la version itérative dans un chapitre précédent.</p>
<p>Le principe de l’algorithme récursif est le suivant :</p>
<ul class="simple">
<li><p>0! = 1, définit la condition d’arrêt.</p></li>
<li><p><em>n</em>! = <em>n</em> * <em>n</em>-1!, définit récursivement ! puisque la définition comprend un appel à !.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="k">def</span> <span class="nf">factorielleRecursif</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorielleRecursif</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="nb">print</span><span class="p">(</span><span class="n">factorielleRecursif</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="mi">2432902008176640000</span>
</pre></div>
</div>
<p>Si l’on augmente progressivement la valeur du paramètre, il existe une valeur
à partir de laquelle se produit une erreur d’exécution liée à l’atteinte de la
profondeur maximale de récursion. C’est une première limite de cette approche.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="nb">print</span><span class="p">(</span><span class="n">factorielleRecursif</span><span class="p">(</span><span class="mi">2868</span><span class="p">))</span>
<span class="o">...</span>
<span class="ne">RecursionError</span><span class="p">:</span> <span class="n">maximum</span> <span class="n">recursion</span> <span class="n">depth</span> <span class="n">exceeded</span> <span class="ow">in</span> <span class="n">comparison</span>
</pre></div>
</div>
</div>
<div class="section" id="suite-de-fibonacci">
<h2>Suite de Fibonacci<a class="headerlink" href="#suite-de-fibonacci" title="Lien permanent vers ce titre">¶</a></h2>
<p>Nous avons vu au chapitre 2 la version itérative de la <a class="reference external" href="https://fr.wikipedia.org/wiki/Suite_de_Fibonacci">suite de Fibonacci</a>
définie par :</p>
<div class="math-wrapper"><div class="math notranslate nohighlight">
\[y_n = y_{n-1} + y_{n-2} \; avec \;  y_0 = 0 \;  et \;  y_1 = 1.\]</div></div>
<p>Dans cette expression :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(y_0 = 0\)</span>  et <span class="math notranslate nohighlight">\(y_1 = 1\)</span> sont les conditions d’arrêt ;</p></li>
<li><p><span class="math notranslate nohighlight">\(y_n = y_{n-1} + y_{n-2}\)</span> définit récursivement la suite
car la partie droite de l’égalité comprend deux appels à la définition de la suite.</p></li>
</ul>
<p>L’implémentation récursive du calcul de la <em>n</em>-ième valeur de la suite découle de
cette définition.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="k">def</span> <span class="nf">fibonacciRecursif</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fibonacciRecursif</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacciRecursif</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="nb">print</span><span class="p">(</span><span class="n">fibonacciRecursif</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="mi">6765</span>
</pre></div>
</div>
<p>Si cet exemple présente une simplicité dans l’écriture, on observera que le
temps d’exécution croit avec l’augmentation de la valeur du
paramètre, ce qui met en évidence une deuxième limite de l’approche
récursive. Cette observation peut être analysée en mesurant le
temps d’exécution. Pour cela, on utilise une fonction qui va calculer
la durée d’exécution par différence de temps en utilisant le module <em>time</em>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">duree</span><span class="p">(</span><span class="n">fonction</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Fonction pour le calcul du temps d'exécution</span>

<span class="sd">    :param fonction: nom de la fonction à exécuter</span>
<span class="sd">    :param n: paramètre qui est passé à la fonction</span>
<span class="sd">    """</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
    <span class="n">fonction</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">duree</span><span class="p">(</span><span class="n">fibonacciRecursif</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="mf">0.015600100000000339</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">duree</span><span class="p">(</span><span class="n">fibonacciRecursif</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="mf">1.0140065000000078</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="n">duree</span><span class="p">(</span><span class="n">fibonacciRecursif</span><span class="p">,</span> <span class="mi">33</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="mf">1.5756101000000058</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Attention, la fonction <em>duree</em> reçoit deux paramètres, le nom de la fonction
dont on souhaite connaître la durée d’exécution et une information qui sera
passée en paramètre à cette fonction.</p>
</div>
<div class="admonition-exercice admonition">
<p class="admonition-title">Exercice</p>
<p>A partir des exemples, quels seraient les temps d’exécution pour <em>n</em> = 34, 35, 36 ?
En décomposant l’exécution de <em>fibonacciRecursif(4)</em>, analyser la raison de
cette augmentation du temps d’exécution.</p>
</div>
<p>On peut réduire de manière importante ce temps d’exécution en supprimant un des appels
récursifs. Rappelons le principe que nous avons vu au chapitre 2.</p>
<div class="figure align-center" id="id2">
<a class="reference internal image-reference" href="_images/Fibonacci.png"><img alt="_images/Fibonacci.png" src="_images/Fibonacci.png" style="width: 160.0px; height: 160.8px;"/></a>
<p class="caption"><span class="caption-number">Fig. 15 </span><span class="caption-text">Principe des décalages à effectuer</span><a class="headerlink" href="#id2" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>Deux opérations sont à effectuer :</p>
<ul class="simple">
<li><p>le calcul de la somme de <span class="math notranslate nohighlight">\(y_{n-1}\)</span> et de <span class="math notranslate nohighlight">\(y_{n-2}\)</span>;</p></li>
<li><p>la propagation de l’information pour l’itération suivante.</p></li>
</ul>
<p>Une représentation matricielle permet de traiter ce problème :</p>
<div class="math-wrapper"><div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
y_{n} \\
y_{n+1}
\end{pmatrix}
=
\begin{pmatrix}
0 &amp; 1 \\
1 &amp; 1
\end{pmatrix}
\cdot
\begin{pmatrix}
y_{n-1} \\
y_{n}
\end{pmatrix}
\; avec \; Y_0 = \begin{pmatrix}
0 \\
1
\end{pmatrix}.\end{split}\]</div></div>
<p>Ce que l’on peut écrire sous la forme :</p>
<div class="math-wrapper"><div class="math notranslate nohighlight">
\[\begin{split}Y_n = M.Y_{n-1} \; avec \; Y_0 = \begin{pmatrix}
0 \\
1
\end{pmatrix}.\end{split}\]</div></div>
<p>L’algorithme récursif découle de cette représentation. Utilisons dans
un premier temps le module <a class="reference external" href="http://www.numpy.org/">numpy</a> pour l’implémenter.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">fibonacciRecursifMatriciel</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]),</span> <span class="n">fibonacciRecursifMatriciel</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Le résultat est une liste représentant le vecteur <span class="math notranslate nohighlight">\(Y_n\)</span> dont la première composante est
la <em>n</em>-ème valeur de la suite.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="nb">print</span><span class="p">(</span><span class="n">fibonacciRecursifMatriciel</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="p">[[</span> <span class="mi">6765</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">10946</span><span class="p">]]</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Tester cet algorithme pour <em>n</em> = 50 et analyser le résultat.</p>
<p>Tester, avec la même valeur de <em>n</em>, l’algorithme suivant qui utilise le module Matrice créé en TD.
On rappelle que la surcharge de l’opérateur <cite>*</cite> est
utilisé pour la multiplication matricielle dans la classe <em>Matrice</em>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">from</span> <span class="nn">ClasseMatrice</span> <span class="kn">import</span> <span class="n">Matrice</span>

<span class="k">def</span> <span class="nf">fibonacciRecursifMatriciel</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Matrice</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Matrice</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span> <span class="o">*</span> <span class="n">fibonacciRecursifMatriciel</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="nb">print</span><span class="p">(</span><span class="n">fibonacciRecursifMatriciel</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="mi">6765</span>
<span class="mi">10946</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="nb">print</span><span class="p">(</span><span class="n">fibonacciRecursifMatriciel</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
<span class="mi">12586269025</span>
<span class="mi">20365011074</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="tri-rapide">
<h2>Tri rapide<a class="headerlink" href="#tri-rapide" title="Lien permanent vers ce titre">¶</a></h2>
<p>Le principe du tri est le suivant :</p>
<ul class="simple">
<li><p>Choisir un pivot.</p></li>
<li><p>Faire une partition de la liste à trier, i.e. trouver l’indice
tel que tous les éléments à gauche soient &lt; au pivot et tous ceux à
droite soient &gt;= au pivot.</p></li>
<li><p>Appeler récursivement l’algorithme avec la liste à gauche du pivot et
celle à droite du pivot.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">triRapide</span><span class="p">(</span><span class="n">liste</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Fonction qui trie une liste selon par l'algorithme</span>
<span class="sd">    du tri rapide (Quick sort)</span>
<span class="sd">    </span>
<span class="sd">    :param liste: la liste à trier</span>
<span class="sd">    :return: liste triée</span>
<span class="sd">    """</span>
    
    <span class="c1"># Fonction locale à la fonction</span>
    <span class="k">def</span> <span class="nf">recursion</span> <span class="p">(</span><span class="n">liste</span><span class="p">,</span> <span class="n">i</span> <span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fonction qui effectue les appels récursifs</span>
<span class="sd">            </span>
<span class="sd">        :param liste: liste à trier</span>
<span class="sd">        :param i: indice du début de la liste à trier</span>
<span class="sd">        :param j: indice de fin de la liste à trier</span>
<span class="sd">        """</span>
        
        <span class="k">def</span> <span class="nf">pivot</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="sd">"""</span>
<span class="sd">            Fonction qui calcule l'indice du pivot par un tirage aléatoire entre i et j</span>
<span class="sd">            </span>
<span class="sd">            :param i: </span>
<span class="sd">            :param j:</span>
<span class="sd">            :return: int</span>
<span class="sd">            """</span>
            <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">liste</span><span class="p">,</span> <span class="n">indicePivot</span> <span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="sd">"""</span>
<span class="sd">            Fonction qui calcule l'indice de partition</span>
<span class="sd">            </span>
<span class="sd">            :param liste: liste à trier</span>
<span class="sd">            :param indicePivot: indice du pivot</span>
<span class="sd">            :param i: indice du début de la liste à trier</span>
<span class="sd">            :param j: indice de fin de la liste à trier</span>
<span class="sd">            :return: int</span>
<span class="sd">            """</span>            
            <span class="n">liste</span><span class="p">[</span><span class="n">indicePivot</span> <span class="p">],</span><span class="n">liste</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">liste</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">liste</span><span class="p">[</span><span class="n">indicePivot</span> <span class="p">]</span>
            <span class="n">partitionIndex</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">liste</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">liste</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">liste</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">liste</span><span class="p">[</span><span class="n">partitionIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">liste</span><span class="p">[</span><span class="n">partitionIndex</span><span class="p">],</span> <span class="n">liste</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">partitionIndex</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">liste</span><span class="p">[</span><span class="n">partitionIndex</span><span class="p">],</span> <span class="n">liste</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">liste</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">liste</span><span class="p">[</span><span class="n">partitionIndex</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">partitionIndex</span>

        <span class="c1"># Corps de la fonction recursion()</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">indicePivot</span> <span class="o">=</span> <span class="n">pivot</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> 
            <span class="n">indicePartition</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">liste</span><span class="p">,</span> <span class="n">indicePivot</span> <span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">recursion</span><span class="p">(</span><span class="n">liste</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">indicePartition</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">recursion</span><span class="p">(</span><span class="n">liste</span><span class="p">,</span> <span class="n">indicePartition</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> 
            
    <span class="c1"># Corps de la fonction triRapide()</span>
    <span class="n">recursion</span><span class="p">(</span><span class="n">liste</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">liste</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">liste</span>
</pre></div>
</div>
</div>
<div class="section" id="tri-fusion">
<h2>Tri fusion<a class="headerlink" href="#tri-fusion" title="Lien permanent vers ce titre">¶</a></h2>
<p>Le tri fusion est un autre tri récursif qui utilise la fonction <em>fusion()</em> vue au chapitre <a class="reference internal" href="ExemplesFonction.html#exemples"><span class="std std-ref">Exemples de fonction</span></a>.</p>
<p>Le principe est le suivant :</p>
<ul class="simple">
<li><p>Si la liste à trier contient plus d’un élement, on fusionne l’appel récursif du tri sur la moitié gauche de la liste et
l’appel récursif du tri sur la moitié droite de la liste.</p></li>
<li><p>Dans le cas contraire, on retourne la liste.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="k">def</span> <span class="nf">triFusion</span><span class="p">(</span><span class="n">liste</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Fonction qui trie une liste selon par l'algorithme</span>
<span class="sd">    du tri fusion (merge sort)</span>
<span class="sd">    </span>
<span class="sd">    :param liste: la liste à trier</span>
<span class="sd">    :return: liste triée</span>
<span class="sd">    """</span>
    
    <span class="c1"># Fonction locale à la fonction</span>
    <span class="k">def</span> <span class="nf">fusion</span><span class="p">(</span><span class="n">liste1</span><span class="p">,</span> <span class="n">liste2</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fonction qui fusionne deux listes</span>
<span class="sd">        </span>
<span class="sd">        :param liste1: liste triée à fusionner</span>
<span class="sd">        :param liste2: liste triée à fusionner</span>
<span class="sd">        :return: liste fusionnée        </span>
<span class="sd">        """</span>
        <span class="n">listeFusionnee</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">compteur1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">compteur2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">longueur1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">liste1</span><span class="p">)</span>
        <span class="n">longueur2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">liste2</span><span class="p">)</span>
        <span class="n">fini</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="k">while</span> <span class="ow">not</span> <span class="n">fini</span><span class="p">:</span>
           <span class="k">if</span> <span class="n">compteur1</span> <span class="o">&lt;</span> <span class="n">longueur1</span> <span class="ow">and</span> <span class="n">compteur2</span> <span class="o">&lt;</span> <span class="n">longueur2</span><span class="p">:</span>
               <span class="k">if</span> <span class="n">liste1</span><span class="p">[</span><span class="n">compteur1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">liste2</span><span class="p">[</span><span class="n">compteur2</span><span class="p">]:</span>
                   <span class="n">listeFusionnee</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">liste1</span><span class="p">[</span><span class="n">compteur1</span><span class="p">])</span>
                   <span class="n">compteur1</span> <span class="o">=</span> <span class="n">compteur1</span> <span class="o">+</span> <span class="mi">1</span>
               <span class="k">else</span><span class="p">:</span>
                   <span class="n">listeFusionnee</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">liste2</span><span class="p">[</span><span class="n">compteur2</span><span class="p">])</span>
                   <span class="n">compteur2</span> <span class="o">=</span> <span class="n">compteur2</span> <span class="o">+</span> <span class="mi">1</span>
           <span class="k">elif</span> <span class="n">compteur1</span> <span class="o">==</span> <span class="n">longueur1</span><span class="p">:</span>
               <span class="n">listeFusionnee</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">liste2</span><span class="p">[</span><span class="n">compteur2</span><span class="p">:])</span>
               <span class="n">fini</span> <span class="o">=</span> <span class="kc">True</span>
           <span class="k">else</span><span class="p">:</span>
               <span class="n">listeFusionnee</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">liste1</span><span class="p">[</span><span class="n">compteur1</span><span class="p">:])</span>
               <span class="n">fini</span> <span class="o">=</span> <span class="kc">True</span>             
        <span class="k">return</span> <span class="n">listeFusionnee</span> 
            
    <span class="c1"># Corps de la fonction triFusion()</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">liste</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fusion</span><span class="p">(</span><span class="n">triFusion</span><span class="p">(</span><span class="n">liste</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">liste</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]),</span> <span class="n">triFusion</span><span class="p">(</span><span class="n">liste</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">liste</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">:]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">liste</span>
    
</pre></div>
</div>
<p>En supposant que les fonctions <em>triBulle()</em>, <em>triRapide()</em>, <em>triFusion()</em> soient dans le fichier <em>Tris.py</em>,
le programme ci-après permet de comparer les trois tris. On analysera la fonction <em>evalue()</em> qui
retourne un dictionnaire contenant le résultat de l’évaluation de la focntion ainsi que son temps
d’exécution.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">Tris</span> <span class="kn">import</span> <span class="n">triBulle</span><span class="p">,</span> <span class="n">triRapide</span><span class="p">,</span> <span class="n">triFusion</span>

<span class="k">def</span> <span class="nf">evalue</span><span class="p">(</span><span class="n">fonction</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Fonction pour évaluer une fonction</span>
<span class="sd">        </span>
<span class="sd">    :param fonction: nom de la fonction à exécuter</span>
<span class="sd">    :param n: paramètre qui est passé à la fonction</span>
<span class="sd">    : return: dictionnaire contenant le résultat de la fonction et la duree</span>
<span class="sd">    """</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">'resultat'</span><span class="p">:</span> <span class="n">fonction</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="s1">'duree'</span><span class="p">:</span> <span class="nb">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="s1">'.3f'</span><span class="p">)}</span>
   
<span class="c1"># Programme comparant les temps d'exécution du tri à bulle</span>
<span class="c1"># et du tri rapide</span>
    
<span class="c1"># Génération d'une liste non triée</span>
<span class="n">listeNonTriee</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
    <span class="n">listeNonTriee</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">))</span>    
<span class="c1">#print(listeNonTriee)</span>
  
<span class="c1"># tri à bulle</span>
<span class="n">liste</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">listeNonTriee</span><span class="p">)</span>
<span class="n">test</span> <span class="o">=</span> <span class="n">evalue</span><span class="p">(</span><span class="n">triBulle</span><span class="p">,</span> <span class="n">liste</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Temps pour le tri bulle'</span><span class="p">,</span> <span class="n">test</span><span class="p">[</span><span class="s1">'duree'</span><span class="p">])</span>   
<span class="c1">#print(test['resultat']) </span>
  
<span class="c1"># tri rapide</span>
<span class="n">liste</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">listeNonTriee</span><span class="p">)</span>
<span class="n">test</span> <span class="o">=</span> <span class="n">evalue</span><span class="p">(</span><span class="n">triRapide</span><span class="p">,</span> <span class="n">liste</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Temps pour le tri rapide'</span><span class="p">,</span> <span class="n">test</span><span class="p">[</span><span class="s1">'duree'</span><span class="p">])</span>   
<span class="c1">#print(test['resultat'])  </span>

<span class="c1"># tri fusion</span>
<span class="n">liste</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">listeNonTriee</span><span class="p">)</span>
<span class="n">test</span> <span class="o">=</span> <span class="n">evalue</span><span class="p">(</span><span class="n">triFusion</span><span class="p">,</span> <span class="n">liste</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Temps pour le tri fusion'</span><span class="p">,</span> <span class="n">test</span><span class="p">[</span><span class="s1">'duree'</span><span class="p">])</span>   
<span class="c1">#print(test['resultat']) </span>
</pre></div>
</div>
<p>L’exécution de ce programme donne l’affichage suivant pour 10000 éléments :</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Temps pour le tri bulle 8.596
Temps pour le tri rapide 0.047
Temps pour le tri fusion 0.047
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Python utilisant des références pour les objets de type liste,
la liste non triée est un objet qu’il faut cloner avec la méthode
<em>copy</em> du module <em>copy</em> pour que chaque tri utilise une liste non
triée.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On pourra ajouter le tri par insertion vu en TD et faire évoluer
le nombre d’éléménts pour analyser qualitativement la complexité
des tris.</p>
<p>Enlever le commentaire devant les impressions pour afficher les listes.</p>
</div>
</div>
<div class="section" id="arbres-binaires">
<h2>Arbres binaires<a class="headerlink" href="#arbres-binaires" title="Lien permanent vers ce titre">¶</a></h2>
<p>Dans ce paragraphe, on s’intéresse à la représentation des arbres binaires. Il
s’agit d’une structure de données permettant de représenter des
hiérarchies. Les éléments de l’arbre sont appelés des nœuds. Dans un arbre binaire
chaque nœud a au plus deux descendants. Par analogie avec un arbre généalogique,
on parle souvent de nœud père et de nœuds fils. Le premier nœud de l’arbre est
appelé racine.</p>
<p>Nous allons illustrer la création d’un arbre et les différents types de parcours
en cherchant à représenter la généalogie de Bart Simpson.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/GenealogieSimpson.png"><img alt="_images/GenealogieSimpson.png" src="_images/GenealogieSimpson.png" style="width: 398.25px; height: 358.5px;"/></a>
</div>
<p>Dans notre exemple, nous proposons de coder un nœud sous la forme d’une liste
contenant trois éléments : la personne à représenter, son père et sa mère.</p>
<p>Pour cela nous définissons la classe Nœud de la manière suivante :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="k">class</span> <span class="nc">Noeud</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">pere</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mere</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Constructeur</span>
<span class="sd">        </span>
<span class="sd">        :param x: chaîne représentant la personne</span>
<span class="sd">        :param pere: Noeud du père de x, initialisé à None si absent</span>
<span class="sd">        :param mere: Noeud de la mère de x, initialisé à None si absent</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noeud</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">pere</span><span class="p">,</span> <span class="n">mere</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Cet exemple illustre l’insertion de code qui sera exécuté si le fichier est exécuté
mais pas s’il est importé. Cette insertion définit la généalogie de Bart Simpson  en créant
un nœud pour Bart dont le père et la mère sont eux-même des nœuds vers leurs
propres parents, c’est-à-dire les grands-parents de Bart. Chaque grand-parent est
lui-même un nœud qui ne contient aucun ascendant.</p>
</div>
<p>Le parcours d’un arbre binaire consiste souvent à visiter tous les noeuds et à
effectuer un traitement lors de cette visite. En partant de la
racine, on visite ses fils et ceci récursivement. On obtient alors trois types
de parcours selon que le traitement est effectué :</p>
<ul class="simple">
<li><p>avant les appels récursifs (on parle de parcours préfixé) ;</p></li>
<li><p>entre les deux appels récursifs (on parle de parcours infixé) ;</p></li>
<li><p>après les deux appels récursifs (on parle de parcours postfixé).</p></li>
</ul>
<p>Ces trois types de parcours sont ajoutés à la classe Noeud sous la forme de
trois méthodes. On obtient alors le code suivant :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="k">class</span> <span class="nc">Noeud</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">pere</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mere</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Constructeur</span>
<span class="sd">        </span>
<span class="sd">        :param x: chaîne représentant la personne</span>
<span class="sd">        :param pere: Noeud du père de x, initialisé à None si absent</span>
<span class="sd">        :param mere: Noeud de la mère de x, initialisé à None si absent</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noeud</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">pere</span><span class="p">,</span> <span class="n">mere</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">parcoursPrefixe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Parcours préfixé : le traitement est avant les </span>
<span class="sd">        deux appels récursifs</span>
<span class="sd">        """</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noeud</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noeud</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noeud</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">parcoursPrefixe</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noeud</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noeud</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">parcoursPrefixe</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">parcoursInfixe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Parcours infixé : le traitement est entre les </span>
<span class="sd">        deux appels récursifs</span>
<span class="sd">        """</span>        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noeud</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noeud</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">parcoursInfixe</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noeud</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noeud</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noeud</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">parcoursInfixe</span><span class="p">()</span>
        
    <span class="k">def</span> <span class="nf">parcoursPostfixe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Parcours postfixé : le traitement est après les </span>
<span class="sd">        deux appels récursifs</span>
<span class="sd">        """</span>            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noeud</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noeud</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">parcoursPostfixe</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noeud</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noeud</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">parcoursPostfixe</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noeud</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># La syntaxe suivante permet l'initialisation de la généalogie de  Bart si on exécute le programme</span>
<span class="c1"># mais pas si on importe le fichier</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">'__main__'</span><span class="p">:</span>
    <span class="n">arbre</span> <span class="o">=</span> <span class="n">Noeud</span><span class="p">(</span>
        <span class="s1">'Bart'</span><span class="p">,</span> 
        <span class="n">Noeud</span><span class="p">(</span>
            <span class="s1">'Homer'</span><span class="p">,</span>
             <span class="n">Noeud</span><span class="p">(</span><span class="s1">'Abraham'</span><span class="p">),</span>
             <span class="n">Noeud</span><span class="p">(</span><span class="s1">'Mona'</span><span class="p">)</span>
        <span class="p">),</span>
        <span class="n">Noeud</span><span class="p">(</span>
            <span class="s1">'Marge'</span><span class="p">,</span>
            <span class="n">Noeud</span><span class="p">(</span><span class="s1">'Clancy'</span><span class="p">),</span>
            <span class="n">Noeud</span><span class="p">(</span><span class="s1">'Jacqueline'</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>       
</pre></div>
</div>
<p>Avec la définition précédente de l’arbre, on obtient les affichages suivants lors
de l’appel des trois méthodes.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">arbre</span><span class="o">.</span><span class="n">parcoursPrefixe</span><span class="p">()</span>
<span class="n">Bart</span>
<span class="n">Homer</span>
<span class="n">Abraham</span>
<span class="n">Mona</span>
<span class="n">Marge</span>
<span class="n">Clancy</span>
<span class="n">Jacqueline</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">arbre</span><span class="o">.</span><span class="n">parcoursInfixe</span><span class="p">()</span>
<span class="n">Abraham</span>
<span class="n">Homer</span>
<span class="n">Mona</span>
<span class="n">Bart</span>
<span class="n">Clancy</span>
<span class="n">Marge</span>
<span class="n">Jacqueline</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="n">arbre</span><span class="o">.</span><span class="n">parcoursPostfixe</span><span class="p">()</span>
<span class="n">Abraham</span>
<span class="n">Mona</span>
<span class="n">Homer</span>
<span class="n">Clancy</span>
<span class="n">Jacqueline</span>
<span class="n">Marge</span>
<span class="n">Bart</span>
</pre></div>
</div>
</div>
<div class="section" id="generateur-de-fractales">
<h2>Générateur de fractales<a class="headerlink" href="#generateur-de-fractales" title="Lien permanent vers ce titre">¶</a></h2>
<p>Les formes fractales possèdent la propriété d’autosimilarité,
c’est-à-dire que leur aspect est le même quelle que soit l’échelle à laquelle on les observe.
Elles constituent un modèle théorique que l’on peut approcher
en ayant la propriété d’autosimilarité vraie jusqu’à un certain ordre.</p>
<div class="figure align-center" id="id3">
<a class="reference internal image-reference" href="_images/Fractales.png"><img alt="_images/Fractales.png" src="_images/Fractales.png" style="width: 590.25px; height: 385.5px;"/></a>
<p class="caption"><span class="caption-number">Fig. 16 </span><span class="caption-text">Exemples de fractales à l’ordre 0, 1 et 2.</span><a class="headerlink" href="#id3" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>Dans la première fractale chaque segment est divisé en trois parties égales.
Le segment intermédiaire est remplacé par deux segments de même longueur.
Pour la seconde fractale, chaque segment est divisé en trois parties égales.
A chaque division, on engendre un segment du tiers de la longueur du segment
initial et formant un angle <em>a</em> ou -<em>a</em> avec le segment initial.</p>
<p>Pour dessiner ces formes fractales on va utiliser le module <a class="reference external" href="https://docs.python.org/3/library/turtle.html">turtle</a>. La tortue
était l’interface du langage LOGO. Ses primitives simples permettent de déplacer
la tortue. La trace laissée par la tortue constitue le dessin.</p>
<ul class="simple">
<li><p>turtle.forward(x) permet de faire avancer la tortue d’une distance <em>x</em> ;</p></li>
<li><p>turtle.left(x) permet de faire tourner la tortue à gauche de <em>x</em> degrés ;</p></li>
<li><p>turtle.right(x) permet de faire tourner la tortue à droite de <em>x</em> degrés ;</p></li>
<li><p>turtle.up() permet de relever la tortue ;</p></li>
<li><p>turtle.down() permet de descendre la tortue.</p></li>
</ul>
<p>On va construire un petit générateur qui va utiliser une grammaire simple
constituée d’un axiome et d’une règle pour représenter la fractale.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Ces grammaires, appelées L-Systèmes ou systèmes de Lindenmayer, ont été créées
pour fournir un modèle théorique de développement des plantes. On trouvera sur le
site de l’université de Calgary consacré à la <a class="reference external" href="http://algorithmicbotany.org/papers/">botanique algorithmique</a> un ensemble
d’informations très intéressantes sur ce sujet, en particulier le livre
<a class="reference external" href="http://algorithmicbotany.org/papers/abop/abop.pdf">The Algorithmic Beauty of Plants</a> de Przemyslaw Prusinkiewicz
et Aristid Lindenmayer en accès libre.</p>
</div>
<p>On utilise le codage suivant :</p>
<ul class="simple">
<li><p>Fx, où <em>x</em> est un nombre, représente un segment. Pour l’axiome,
<em>x</em> est la longueur du segment. Pour la règle, <em>x</em> représente
la proportion du segment utilisé au moment de l’application de la règle ;</p></li>
<li><p>Lx, où <em>x</em> est un nombre, définit une rotation à gauche de <em>x</em> degrés ;</p></li>
<li><p>Rx, où <em>x</em> est un nombre, définit une rotation à droite de <em>x</em> degrés ;</p></li>
<li><p>U relève la tortue ;</p></li>
<li><p>D descend la tortue ;</p></li>
<li><p>une expression entre [] définit une branche.</p></li>
</ul>
<p>En utilisant ce principe la première fractale peut être représentée par :</p>
<ul class="simple">
<li><p>axiome : L30F300 (rotation à gauche de 30 degrés et segment de longueur
300 ;</p></li>
<li><p>règle : F0.333L60F0.333R120F0.333L60F0.333 (segment d’un tiers de la longueur
puis rotation à gauche de 60 degrés puis segment d’un tiers de la longueur …).</p></li>
</ul>
<p>La seconde fractale s’exprime selon le même principe en introduisant deux branches.</p>
<ul class="simple">
<li><p>axiome : L30F300</p></li>
<li><p>règle : F0.333[L30F0.333]F0.333[R30F0.333]F0.333</p></li>
</ul>
<p>Le code du générateur est le suivant :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">turtle</span>
<span class="kn">import</span> <span class="nn">re</span>
  
<span class="k">class</span> <span class="nc">turtleFractale</span><span class="p">(</span><span class="n">turtle</span><span class="o">.</span><span class="n">Turtle</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Classe turtleFractale</span>
<span class="sd">    </span>
<span class="sd">    Cette classe hérite de la classe Turtle</span>
<span class="sd">    """</span>
      
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axiome</span><span class="p">,</span> <span class="n">regle</span><span class="p">,</span> <span class="n">profondeur</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Constructeur</span>
<span class="sd">        </span>
<span class="sd">        :param axiome: axiome</span>
<span class="sd">        :param regle: règle de réécriture</span>
<span class="sd">        :param profondeur: profondeur de récursion</span>
<span class="sd">        """</span>
        <span class="n">turtle</span><span class="o">.</span><span class="n">hideturtle</span><span class="p">()</span>
        <span class="n">turtle</span><span class="o">.</span><span class="n">speed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axiome</span> <span class="o">=</span> <span class="n">axiome</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regle</span> <span class="o">=</span> <span class="n">regle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profondeur</span> <span class="o">=</span> <span class="n">profondeur</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pile</span> <span class="o">=</span> <span class="p">[]</span>
      
    <span class="k">def</span> <span class="nf">empile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fonction qui insère dans la pile</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pile</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">turtle</span><span class="o">.</span><span class="n">pos</span><span class="p">(),</span> <span class="n">turtle</span><span class="o">.</span><span class="n">heading</span><span class="p">()])</span>
          
    <span class="k">def</span> <span class="nf">depile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fonction qui supprime le sommet de la pile</span>
<span class="sd">        """</span>
        <span class="n">localisation</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pile</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">turtle</span><span class="o">.</span><span class="n">setpos</span><span class="p">(</span><span class="n">localisation</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">turtle</span><span class="o">.</span><span class="n">setheading</span><span class="p">(</span><span class="n">localisation</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>   
          
    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profondeur</span><span class="p">,</span> <span class="n">regle</span><span class="p">,</span> <span class="n">longueur</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fonction qui analyse la règle</span>
<span class="sd">        </span>
<span class="sd">        :param profondeur: profondeur de la récursion</span>
<span class="sd">        :param regle: règle</span>
<span class="sd">        :param longueur: longueur d'un segment</span>
<span class="sd">        """</span>
        <span class="n">patterns</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">'([LRFUD\[\]])(\d+(?:\.\d+)?)?'</span><span class="p">,</span> <span class="n">regle</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>       
            <span class="k">if</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'L'</span><span class="p">:</span>
                <span class="c1"># Fait tourner la tortue à gauche</span>
                <span class="n">turtle</span><span class="o">.</span><span class="n">left</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'R'</span><span class="p">:</span>
                <span class="c1"># Fait tourner la tortue à droite</span>
                <span class="n">turtle</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> 
            <span class="k">elif</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'U'</span><span class="p">:</span>
                <span class="c1"># Relève la tortue                </span>
                <span class="n">turtle</span><span class="o">.</span><span class="n">up</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'D'</span><span class="p">:</span>
                <span class="c1"># Baisse la tortue                </span>
                <span class="n">turtle</span><span class="o">.</span><span class="n">down</span><span class="p">()</span>                
            <span class="k">elif</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'F'</span><span class="p">:</span>
                <span class="c1"># Recursion croisée          </span>
                <span class="bp">self</span><span class="o">.</span><span class="n">recursion</span><span class="p">(</span><span class="n">profondeur</span><span class="p">,</span> <span class="n">longueur</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'['</span><span class="p">:</span>
                <span class="c1"># Place la position et l'orientation de la tortue dans la pile</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">empile</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">']'</span><span class="p">:</span>
                <span class="c1"># Relève la tortue</span>
                <span class="n">turtle</span><span class="o">.</span><span class="n">up</span><span class="p">()</span>
                <span class="c1"># Dépile la dernière localisation et ramène la tortue à celle-ci</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">depile</span><span class="p">()</span>
                <span class="c1"># Baisse la tortue</span>
                <span class="n">turtle</span><span class="o">.</span><span class="n">down</span><span class="p">()</span> 
                  
    <span class="k">def</span> <span class="nf">dessine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>    
        <span class="sd">"""</span>
<span class="sd">        Fonction qui dessine la fractale</span>
<span class="sd">        """</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">analyse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profondeur</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axiome</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
          
    <span class="k">def</span> <span class="nf">recursion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profondeur</span><span class="p">,</span> <span class="n">longueur</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fonction qui fait avancer la tortue ou appelle récursivement la </span>
<span class="sd">        fonction dessine</span>
<span class="sd">        </span>
<span class="sd">        :param profondeur: profondeur de la récursion</span>
<span class="sd">        :param longueur: longueur d'un segment</span>
<span class="sd">        """</span>       
        <span class="k">if</span> <span class="n">profondeur</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Fait avancer la tortue</span>
            <span class="n">turtle</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">longueur</span><span class="p">)</span>                    
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Récursion croisée</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analyse</span><span class="p">(</span><span class="n">profondeur</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">regle</span><span class="p">,</span> <span class="n">longueur</span><span class="p">)</span>
  
    
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>L’analyse de l’axiome et de la règle est faite en utilisant une
<a class="reference external" href="https://docs.python.org/3/library/re.html">expression régulière</a> et la méthode <em>findall()</em>. A titre d’exercice
on analysera l’expression régulière.</p>
<p>Ce code utilise une récursivité croisée puisque la méthode
<em>analyse</em> appelle la méthode <em>recursion</em> qui appelle elle-même la
méthode <em>analyse</em>.</p>
<p>Un mécanisme de pile, construit à partir d’une liste, permet de gérer les branches.</p>
</div>
<p>A titre d’exemple le code suivant produit une simulation de brin d’herbe
dont le résultat est représenté <a class="reference internal" href="#herbe"><span class="std std-numref">Fig. 17</span></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">turtle</span><span class="o">.</span><span class="n">setworldcoordinates</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span><span class="mi">310</span><span class="p">,</span><span class="mi">310</span><span class="p">)</span>
 <span class="o">...</span><span class="p">:</span> <span class="n">maTortue</span> <span class="o">=</span> <span class="n">turtleFractale</span><span class="p">(</span>
 <span class="o">...</span><span class="p">:</span>    <span class="s1">'[L90F300][L80F200][L60F150]'</span><span class="p">,</span>
 <span class="o">...</span><span class="p">:</span>    <span class="s1">'F0.333R5[L30F0.333]F0.333[R30F0.333]F0.333'</span><span class="p">,</span>
 <span class="o">...</span><span class="p">:</span>    <span class="mi">3</span>
 <span class="o">...</span><span class="p">:)</span>
 <span class="o">...</span><span class="p">:</span> <span class="n">maTortue</span><span class="o">.</span><span class="n">dessine</span><span class="p">()</span>
 <span class="o">...</span><span class="p">:</span> <span class="n">turtle</span><span class="o">.</span><span class="n">exitonclick</span><span class="p">()</span>
 <span class="o">...</span><span class="p">:</span>
 <span class="o">...</span><span class="p">:</span> <span class="c1"># Pour une sortie sans erreur</span>
 <span class="o">...</span><span class="p">:</span> <span class="k">try</span><span class="p">:</span>
 <span class="o">...</span><span class="p">:</span>     <span class="n">turtle</span><span class="o">.</span><span class="n">bye</span><span class="p">()</span>
 <span class="o">...</span><span class="p">:</span> <span class="k">except</span> <span class="n">turtle</span><span class="o">.</span><span class="n">Terminator</span><span class="p">:</span>
 <span class="o">...</span><span class="p">:</span>     <span class="k">pass</span>
 <span class="o">...</span><span class="p">:</span>
</pre></div>
</div>
<div class="figure align-center" id="id4">
<span id="herbe"></span><a class="reference internal image-reference" href="_images/Herbe.png"><img alt="_images/Herbe.png" src="_images/Herbe.png" style="width: 520.5px; height: 458.25px;"/></a>
<p class="caption"><span class="caption-number">Fig. 17 </span><span class="caption-text">Simulation d’un brin d’herbe</span><a class="headerlink" href="#id4" title="Lien permanent vers cette image">¶</a></p>
</div>
<div class="admonition-exercice admonition">
<p class="admonition-title">Exercice</p>
<p>Donner l’axiome et la règle permettant d’obtenir le triangle de
Sierpiński représenté <a class="reference internal" href="#sierpinski"><span class="std std-numref">Fig. 18</span></a> à l’ordre 4.</p>
</div>
<div class="figure align-center" id="id5">
<span id="sierpinski"></span><a class="reference internal image-reference" href="_images/Sierpinski.png"><img alt="_images/Sierpinski.png" src="_images/Sierpinski.png" style="width: 729.75px; height: 633.0px;"/></a>
<p class="caption"><span class="caption-number">Fig. 18 </span><span class="caption-text">Triangle de Sierpiński</span><a class="headerlink" href="#id5" title="Lien permanent vers cette image">¶</a></p>
</div>
</div>
</div>

      </article>
      <footer>
        
        <div class="related-pages">
          
          <a class="prev-page" href="ExemplesObjet.html">
              <svg><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Exemples de classe</div>
                
              </div>
            </a>
        </div>

        <div class="related-information">
              Copyright &#169; 2020, Laurent Foulloy
            |
            <a class="muted-link" href="_sources/Recursivite.rst.txt"
               rel="nofollow">
              Montrer le code source
            </a>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            Contenu
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">La récursivité</a><ul>
<li><a class="reference internal" href="#definitions">Définitions</a></li>
<li><a class="reference internal" href="#calcul-de-n">Calcul de <em>n</em>!</a></li>
<li><a class="reference internal" href="#suite-de-fibonacci">Suite de Fibonacci</a></li>
<li><a class="reference internal" href="#tri-rapide">Tri rapide</a></li>
<li><a class="reference internal" href="#tri-fusion">Tri fusion</a></li>
<li><a class="reference internal" href="#arbres-binaires">Arbres binaires</a></li>
<li><a class="reference internal" href="#generateur-de-fractales">Générateur de fractales</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </main>
</div>
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="_static/scripts/main.js?digest=e931d09b2a40c1bb82b542effe772014573baf67"></script></body>
</html>